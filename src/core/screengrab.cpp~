/***************************************************************************
 *   Copyright (C) 2009 by Artem 'DOOMer' Galichkin                        *
 *   doomer3d@gmail.com                                                    *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/

#include <QtCore/QMutex>
#include <QtCore/QWaitCondition>
#include <QtGui/QApplication>
#include <QtGui/QDesktopWidget>
#include "src/core/screengrab.h"

#ifdef Q_WS_WIN
#include <windows.h>
#endif

#ifdef Q_WS_X11

#include "src/common/netwm/netwm.h"
using namespace netwm;

#include <X11/Xlib.h>
#include <QX11Info>
#endif

screengrab* screengrab::corePtr = 0;

screengrab::screengrab() 
{        
    // load configuration
    conf = Config::instance();
    conf->loadSettings();

    pixelMap = new QPixmap;
    scrNum = 0;

    // delay on 250 msec
    QMutex mutex;
    mutex.lock();
    QWaitCondition pause;
    pause.wait(&mutex, 250);

    // get screen
    screenShot();

    // auto saving first screenshot
    if (conf->getAutoSave() == true)
    {
        QString format = conf->getSaveFormat();
        QString filePath = getSaveFilePath(format);
        writeScreen(filePath, format);
    }      
    qDebug() << "creating scrreengrab obkect";    
}

screengrab::screengrab(const screengrab& ): QObject()
{

}

screengrab& screengrab::operator=(const screengrab& )
{
    
}

screengrab* screengrab::instance()
{
    if (!corePtr)
    {
	corePtr = new screengrab;
    }
    return corePtr;
}

screengrab::~screengrab()
{    
    delete pixelMap;
    conf->killInstance();    
//     if (corePtr)
//     {
// 	delete corePtr;
// 	corePtr = NULL;
//     }
    
    
    qDebug() << "destroing scrreengrab obkect";
}

void screengrab::slotQuit()
{
    // quit appen
    if (corePtr)
    {
	delete corePtr;
	corePtr = NULL;
	qDebug() << "kill corePtr";
    }
    qDebug() << "quit";
    qApp->quit();
//     if (conf->getSavedSizeOnExit() == true)
//     {        
// 	conf->setRestoredWndSize(width(), height());       
// 	conf->saveWndSize();
//     }
//     qApp->quit();
    // TODO -- check close to tray options
}


// get screenshot
void screengrab::screenShot()
{
    // grb pixmap of desktop
    switch(conf->getTypeScreen())
    {
        case 0:
        {
            *pixelMap = QPixmap::grabWindow(QApplication::desktop()->winId());
            break;
        }
        case 1:
            {
#ifdef Q_WS_WIN
    getActiveWind_Win32();
#endif
#ifdef Q_WS_X11
    getActiveWind_X11();
#endif
                break;
            }
        case 2:
            {
            RegionSelect *selector;
            selector = new RegionSelect(conf);
            int resilt = selector->exec();

            if (resilt == QDialog::Accepted)
            {
                *pixelMap = selector->getSelection();
            }
            delete selector;
            break;
            }
        default:
            *pixelMap = QPixmap::grabWindow(QApplication::desktop()->winId()); break;
    }
    
    Q_EMIT newScreenShot(pixelMap);
    
    if (conf->getAutoSave() == true)
    {
	autoSave();
    }
}

#ifdef Q_WS_X11
void screengrab::getActiveWind_X11()
{
    netwm::init();
    Window *wnd = reinterpret_cast<ulong *>(netwm::property(QX11Info::appRootWindow(), NET_ACTIVE_WINDOW, XA_WINDOW));

    if(!wnd)
    {
        *pixelMap = QPixmap::grabWindow(QApplication::desktop()->winId());
        exit(1);
    }

    // no dectortions option is select
    if (conf->getNoDecorX11() == true)
    {
        *pixelMap = QPixmap::grabWindow(*wnd);
        return;
    }

    unsigned int d;
    int status;
    int stat;

//    if (status != 0) {
      Window rt, *children, parent;

    // Find window manager frame
    // TODO -- check to optimize infinity loop
    while (true)
    {
        status = XQueryTree(QX11Info::display(), *wnd, &rt, &parent, &children, &d);
        if (status && (children != None))
        {
            XFree((char *) children);
        }

        if (!status || (parent == None) || (parent == rt))
        {
            break;
        }

        *wnd = parent;
    }

    XWindowAttributes attr; // window attributes
    stat = XGetWindowAttributes(QX11Info::display(), *wnd, &attr);

    if ((stat == False) || (attr.map_state != IsViewable))
    {
        qDebug() << "return NULL";
    }

    // get wnd size
    int rx = 0, ry = 0, rw = 0, rh = 0;
    rw = attr.width;
    rh = attr.height;
    rx = attr.x;
    ry = attr.y;

    *pixelMap = QPixmap::grabWindow(QApplication::desktop()->winId(), rx, ry, rw, rh);

    XFree(wnd);
}
#endif

#ifdef Q_WS_WIN
void screengrab::getActiveWind_Win32()
{
    HWND findWindow = GetForegroundWindow();

    if (findWindow == NULL)
    {
        return;
    }

    if (findWindow == GetDesktopWindow())
    {
        return;
    }

    ShowWindow(findWindow, SW_SHOW);
    SetForegroundWindow(findWindow);

    HDC hdcScreen = GetDC(NULL);

    RECT rcWindow;
    GetWindowRect(findWindow, &rcWindow);

    if (IsZoomed(findWindow))
    {
        if (QSysInfo::WindowsVersion >= QSysInfo::WV_VISTA)
        {
          rcWindow.right -= 8;
          rcWindow.left += 8;
          rcWindow.top += 8;
          rcWindow.bottom -= 8;
        }
        else
        {
          rcWindow.right += 4;
          rcWindow.left -= 4;
          rcWindow.top += 4;
          rcWindow.bottom -= 4;
        }
    }

    HDC hdcMem = CreateCompatibleDC(hdcScreen);
    HBITMAP hbmCapture = CreateCompatibleBitmap(hdcScreen, rcWindow.right - rcWindow.left, rcWindow.bottom - rcWindow.top);
    SelectObject(hdcMem, hbmCapture);

    BitBlt(hdcMem, 0, 0, rcWindow.right - rcWindow.left, rcWindow.bottom - rcWindow.top, hdcScreen, rcWindow.left, rcWindow.top, SRCCOPY);

    ReleaseDC(findWindow, hdcMem);
    DeleteDC(hdcMem);

    *pixelMap = QPixmap::fromWinHBITMAP(hbmCapture);

    DeleteObject(hbmCapture);
}
#endif

// new dcreen
// bool screengrab::getScreen()
// {
//     screenShot();
//     qDebug() << 'get screen slot';
//     return true;
// }

// TODO - rebuild in Config class
QString screengrab::getSaveFilePath(QString format)
{    
    QString initPath;    
    if (conf->getDateTimeInFilename() == true)
    {
        #ifdef Q_WS_X11
            initPath = conf->getSaveDir()+conf->getSaveFileName() +"-"+getDateTimeFileName() +"."+format;
        #endif
        #ifdef Q_WS_WIN
            initPath = conf->getSaveDir()+conf->getSaveFileName()+"-"+getDateTimeFileName();
        #endif
    }
    else
    {
        if (scrNum != 0 && conf->getAutoSave() == true)
        {
        #ifdef Q_WS_X11
            initPath = conf->getSaveDir()+conf->getSaveFileName()+"-" +QString::number(scrNum) +"."+format;
        #endif
        #ifdef Q_WS_WIN
            initPath = conf->getSaveDir()+conf->getSaveFileName()+"-"+QString::number(scrNum);
        #endif
        }
        else
        {
        #ifdef Q_WS_X11
            initPath = conf->getSaveDir() + conf->getSaveFileName()+"."+format;
        #endif
        #ifdef Q_WS_WIN
            initPath = conf->getSaveDir()+conf->getSaveFileName();
        #endif
        }

    } 

    return initPath;
}

QString screengrab::getDateTimeFileName()
{
    QString currentDateTime = QDateTime::currentDateTime().toString(conf->getDateTimeTpl());

    return currentDateTime ;// + "-" + currentTime;
}

// save screen
bool screengrab::writeScreen(QString& fileName, QString& format)
{

    // aitoncrement number screen in autosaving
    if (conf->getAutoSave() == true && conf->getDateTimeInFilename() == false)
    {
        scrNum++;
    }

    // adding extension  format
    if (!fileName.contains("."+format) )
    {
        fileName.append("."+format);
    }

    // writing file
    bool saved;
    if (fileName.isEmpty() == false)
    {        ;
        if (pixelMap->save(fileName,format.toAscii()) == true)
        {            
            saved = true;
        }
        else
        {
            saved = false;
        }        
    }
    else
    {
        saved = false;
    }

    return saved;
}

void screengrab::copyScreen()
{
    QApplication::clipboard()->setPixmap(*pixelMap, QClipboard::Clipboard);
}

QString screengrab::autoSave()
{
    
//     if (conf->getAutoSave() == true)
//     {
	QString format = conf->getSaveFormat();
	QString fileName = getSaveFilePath(format);
	
	if (writeScreen(fileName, format) == true)
	{    
	    qDebug() << "autosaved";
	    return fileName;
	    // 	     trayShowMessage(tr("Saved"),tr("Saved")+ fileName + tr(" is saved"));
	}
// 	else
// 	{
// 	    return "";
// 	}
//     }
        
//     else
    /*{
		    trayShowMessage(tr("New screen"), tr("New screen is getting!"));
    }*/
}


QString screengrab::getVersionPrintable()
{
    QString str = "ScreenGrab: " + qApp->applicationVersion() + QString("\n");
    str += "Qt: " + QString(qVersion()) + QString("\n");
    return str;
}

QPixmap screengrab::getPixmap()
{
    return *pixelMap;
}
